/**********************************************************************************
*
* MAD-X input script for space charge simulations using the LHC proton flat bottom 
* optics (with low-chromaticity). A large number of elements are removed from the 
* sequence to decrease tracking time.
*
* 22/08/2019 - Alexander Huschauer
************************************************************************************/
 
/******************************************************************
 * Energy and particle type definition
 ******************************************************************/

BEAM, PARTICLE=PROTON, PC = 2.14;
BRHO      := BEAM->PC * 3.3356;

/******************************************************************
 * Call lattice files
 ******************************************************************/

call, file="../../ps_mu.seq";
call, file="../../ps_ss.seq";
call, file="../../ps.str";
call, file="../../scenarios/lhc_proton/1_flat_bottom/ps_fb_lhc.str";

/***********************************************************************
 * RFV can be used to manually seet the RF cavity voltage.
 * This is overridden by a PTC RF table (called from PyORBIT).
 **********************************************************************/
RFV = 0.021;

/******************************************************************
 * SEQEDIT to remove unwanted elements
 ******************************************************************/
 
use, sequence = PS;
twiss, file = 'initial_lattice.tfs';

seqedit,sequence = PS;
	flatten;
endedit;

seqedit,sequence = PS;
	call, file = 'remove_elements.seq';
	remove, element=SELECTED;
endedit;

/******************************************************************
 * Cycle the sequence to a different initial location if desired
 ******************************************************************/

PR.BWSV64 : MONITOR, L = 0.0; 

seqedit, sequence=PS;
	flatten;
	install, element=PR.BWSV64, at=0.4, from=PS64$START;
	flatten;
endedit;

use, sequence=PS;

seqedit, sequence=PS;
	flatten;
	cycle , start=PR.BWSV64;
	flatten;
endedit;

/******************************************************************
 * Multipole matching
 ******************************************************************/
use, sequence = PS;

ptc_chrom_macro: macro={
  ptc_create_universe;
  ptc_create_layout,time=false,model=2,method=6,nst=3,exact=true;
  select_ptc_normal, q1=0, q2=0;
  select_ptc_normal,dq1=1,dq2=1;
  select_ptc_normal,dq1=2,dq2=2;
  select_ptc_normal,dq1=3,dq2=3;
  ptc_normal,closed_orbit,normal,icase=5,no=4;
  ptc_end;
  qx0 =table(normal_results,value,1);
  qx1 =table(normal_results,value,3);
  qx2 =table(normal_results,value,5);
  qx3 =table(normal_results,value,7);
  qy0 =table(normal_results,value,2);
  qy1 =table(normal_results,value,4);
  qy2 =table(normal_results,value,6);
  qy3 =table(normal_results,value,8);
  value, qx0, qx1, qx2, qx3, qy0, qy1, qy2, qy3;
};

match,use_macro;
	vary,name=PFKI1F;
	vary,name=PFKI1D;
	vary,name=PFKI2F;
	vary,name=PFKI2D;
	vary,name=PFKI3F;
	vary,name=PFKI3D;
	use_macro,name=ptc_chrom_macro;
	constraint,expr= qx0= 1*MQx0;
	constraint,expr= qy0= 1*MQy0;
	constraint,expr= qx1= 1*MQx1;
	constraint,expr= qy1= 1*MQy1;
	constraint,expr= qx2= 2*MQx2;
	constraint,expr= qy2= 2*MQy2;
jacobian,calls=50000,bisec=3;
ENDMATCH;

value,PFKI1F,PFKI2F,PFKI3F;
value,PFKI1D,PFKI2D,PFKI3D;

Assign, echo=terminal;

value,qx0,qx1,qx2/2;
value,qy0,qy1,qy2/2;

/***********************************************************************
 * Next we use a ptc macro to match the tunes in the lattice to
 * desired values tune_x and tune_y.
 *
 * Using model=2, exact=true is recommended.
 **********************************************************************/
tune_x = 0.21;
tune_y = 0.10;
 
ptc_twiss_tune_macro_false_split: macro={
  ptc_create_universe;
  ptc_create_layout, time=true, model=2, exact=true, method=6, nst=3;
  ptc_twiss, closed_orbit, table = ptc_twiss, icase=56, no=2, summary_table=ptc_twiss_summary;
  qx0=table(ptc_twiss_summary,Q1);
  qy0=table(ptc_twiss_summary,Q2);
  value, qx0, qy0;
  ptc_end;
};

use, sequence=PS;
match, use_macro;
  vary,   name=iqf, step=1.0E-6 ;
  vary,   name=iqd, step=1.0E-6 ;
  USE_MACRO, name=ptc_twiss_tune_macro_false_split;
  CONSTRAINT, expr=  table(ptc_twiss_summary,Q1)= tune_x;
  CONSTRAINT, expr=  table(ptc_twiss_summary,Q2)= tune_y;
  JACOBIAN,calls=10000,bisec=3,TOLERANCE=1.0E-21;
ENDMATCH;
value, IQF, IQD;

/***********************************************************************
 * Next we use the PTC script resplit.ptc - this is used to split
 * defined elements (dipole, quadrupole, sextupole families etc) in
 * order to introduce space charge nodes inside their length. See the
 * file for further information. Then the flat file is generated and 
 * saved.
 **********************************************************************/

ptc_create_universe;
ptc_create_layout,time=true, model=2, exact=true, method=6, nst=3;
ptc_script, file="./resplit.ptc";
ptc_script, file="./print_flat_file.ptc";
select, flag=ptc_twiss, clear; 
select, flag=ptc_twiss, column=name, betx, px, bety, py, disp3, disp3p, disp1, disp1p;
ptc_twiss, icase=5, no=4, deltap_dependency, closed_orbit, file, table=ptc_twiss;
ptc_end;


/******************************************************************
 * Create flat file
 ******************************************************************/

!use, sequence = PS;
!twiss, file = 'simplified_lattice.tfs';

!ptc_create_universe;
!ptc_create_layout,time=true, model=2, exact=true, method=6, nst=5;
!ptc_script, file="./print_flat_file.ptc"; 
!ptc_end;
